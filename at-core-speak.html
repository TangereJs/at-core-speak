<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-theme/at-theme.html" />
<link rel="import" href="../at-carbon-icon-button/at-carbon-icon-button.html" />

<script src="lib/ua-parser.min.js"></script>
<script src="lib/ssml-parser.js"></script>

<dom-module id="at-core-speak">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
    </style>
    
    <div hidden$="[[supported]]">Speach synthesis is not supported by this browser</div>
    
    <at-carbon-icon-button hidden$="[[!_computePlayButtonVisible(supported, mode)]]" disabled$="[[_inProgress]]" icon="now:play" on-tap="_handlePlayButtonOnTap"></at-carbon-icon-button>

  </template>
</dom-module>
<script>
  Polymer({
    is: "at-core-speak",
    properties: {

      value: {
        type: String,
        value: '',
        xtype: 'code',
        mode: 'ssml',
        xgridcols: "12",
        observer: '_valueChanged'
      },

      mode: {
        type: String,
        value: "auto",
        xtype: 'enum',
        xvaluelist: [ 
          { title: 'auto', value: 'auto' },
          { title: 'play', value: 'play' },
          { title: 'button', value: 'button' }
        ]
      },

      supported: {
        type: Boolean,
        value: false,
        readOnly: true
      },

      // TODO: should this be public ??? 
      _inProgress: {
        type: Boolean,
        value: false,
        readOnly: true
      },

    },

    _computePlayButtonVisible: function(supported, mode) {
      return supported && mode === "button";
    },

    ready: function () {
      this._setSupported(!!window.speechSynthesis);

      if (!this.supported) {
        return;
      }
    },

    _valueChanged: function(newValue, oldValue) {
      // validate newValue
      if (!this._isString(newValue)) return;

      if (this.mode === "auto") {
        this.play();
      }
    },

    _isString: function(obj) {
      return Object.prototype.toString.apply(obj) === "[object String]";
    },

    _wrapIntoXmlAndSpeak: function(value) {
      var result = [];
      result.push('<?xml version="1.0"?>');
      result.push('<speak version="1.0" xmlns="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2001/10/synthesis http://www.w3.org/TR/speech-synthesis/synthesis.xsd" xml:lang="en-US">');
      result.push(value);
      result.push('</speak>');
      return result.join("");
    },

    play: function() {
      if (!this.supported) return;

      if (!this.value) return;

      if (this._inProgress) return;

      if (!this._userAgent) {
        this._userAgent = UAParser(navigator.userAgent);
      }
        
      var value = this.value;
      
      // when browser is Edge code needs to check 
      // 1) if <?xml> declaration already exists
      // 2) if <speak> root element already exists
      // 3) check that <speak> root element has necessary attributes
      // 4) when 1, 2 and 3 are false, above elements need to be created

      if (this._userAgent.browser.name === "Edge") {
        var div = document.createElement('div');
        div.innerHTML = value;

        var childNodes = div.childNodes;

        // go through child nodes
        // ignore empty text nodes (new lines etc)
        // check if xml decl element exists
        // check if speak element exists

        // if value doesn't have xml decl elt or speak elt, wrap

        // handle edge cases (pun unintended)

        debugger;
        if (childNodes.length !== 2) {
          // this means that we have value that should be wrapped
          value = this._wrapIntoXmlAndSpeak(value);
        
        } else {
          // check that first child is xml
          var xmlNode = childNodes[0];
          var hasXmlDecl = xmlNode.nodeValue.indexOf("?xml") === 0;

          // check that second child is speak
          var speakNode = childNodes[1];
          var isSpeakNode = speakNode.nodeName === "SPEAK";

          if (!hasXmlDecl && !isSpeakNode) {
            debugger;
            // wrap into xml and speak
            value = this._wrapIntoXmlAndSpeak(value);
          
          } else if (hasXmlDecl && !isSpeakNode) {
            // ignore xml delc and wrap second node into xml and speak
            debugger;
            value = this._wrapIntoXmlAndSpeak(speakNode.nodeValue);

          } else if (!hasXmlDecl && isSpeakNode) {
            // take speak node content and wrap into xml and speak
            debugger;
            value = this._wrapIntoXmlAndSpeak(speakNode.innerHTML);
          
          // } else {
            // has xml node and speak node; do nothing
            // 
          }
        }
      
      } else if (this._userAgent.browser.name === "Firefox") {
        value = window.stripSsml(value);
      }

      var ut = new SpeechSynthesisUtterance(value);

      // Ref material
      // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis
      // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance

      if (!this._boundOnStartHandler) {
        this._boundOnStartHandler = this._handleUtteranceOnStart.bind(this);
      }
      ut.onstart = this._boundOnStartHandler;

      if(!this._boundOnEndHandler) {
        this._boundOnEndHandler = this._handleUtteranceOnEnd.bind(this);
      }
      ut.onend = this._boundOnEndHandler;

      if (!this._boundOnErrorHandler) {
        this._boundOnErrorHandler = this._handleUtteranceOnError.bind(this);
      }
      ut.onerror = this._boundOnErrorHandler;

      window.speechSynthesis.speak(ut);
    },

    _handlePlayButtonOnTap: function(event) {
      this.play();
    },

    _handleUtteranceOnStart: function(event) {
      this._set_inProgress(true);
    },

    _handleUtteranceOnEnd: function(event) {
      this._set_inProgress(false);
    },

    _handleUtteranceOnError: function(event) {
      this._set_inProgress(false);
    },

  });
</script>
